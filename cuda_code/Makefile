# CUDA directory:
CUDA_ROOT_DIR=/usr/local/cuda
# CUDA library directory:
CUDA_LIB_DIR= -L$(CUDA_ROOT_DIR)/lib64
# CUDA include directory:
CUDA_INC_DIR= -I$(CUDA_ROOT_DIR)/include
# CUDA linking libraries:
CUDA_LINK_LIBS= -lcudart -lcusparse -lcublas

CXX = g++
INC_FLAGS := -I/home/grads/ghaoqi1/opt/glog/build -I/home/grads/ghaoqi1/opt/glog/src -I/home/grads/ghaoqi1/opt/gflags/build/include
LIB_FLAGS := -L/home/grads/ghaoqi1/opt/glog/build -L/home/grads/ghaoqi1/opt/gflags/build/lib 
CXXFLAGS = -std=c++14 -O2
CXX_LINK_FLAGS = -lglog -lgflags -lpthread
WARN_FLAGS = -g -Wall -Wextra -Wabi -Wctor-dtor-privacy -Wnon-virtual-dtor -Wreorder -Wstrict-null-sentinel -Woverloaded-virtual -Wshadow -Wcast-align -Wpointer-arith -Wwrite-strings -Wundef -Wredundant-decls

NVXX = nvcc
#NVXXFLAGS = -arch sm_80
NVXX_LINK_FLAGS = -lcusparse -lcublas -lcudart


SRC = ./src
CPP_SRC = ${SRC}/cpp
CUDA_SRC = ${SRC}/cuda
INC = ./include
OBJ = ./obj

CC_SOURCE = $(wildcard ${SRC}/*.cc)
CU_SOURCE = $(wildcard ${SRC}/*.cu)

CC_OBJECTS = $(patsubst %.cc,$(OBJ)/%.cc.o,$(notdir ${CC_SOURCE}))
CU_OBJECTS = $(patsubst %.cu,$(OBJ)/%.cu.o,$(notdir ${CU_SOURCE}))
#OBJECTS = main.o graphdata.o OptionParser.o acc.o pec.o analysis.o 

test:
	@echo ${SRC}
	@echo ${CC_OBJECTS}
	@echo ${CU_OBJECTS}

exe: $(CC_OBJECTS) $(CU_OBJECTS)
	$(CXX) -o $@ $^ $(CXX_LINK_FLAGS) $(NVXXFLAGS) $(WARN_FLAGS) $(CUDA_INC_DIR) $(CUDA_LIB_DIR) $(CUDA_LINK_LIBS) $(LIB_FLAGS)
	#$(CXX) -o $@ $^ $(CUDA_INC_DIR) $(CUDA_LIB_DIR) $(CUDA_LINK_LIBS) $(NVXX_LINK_FLAGS) $(NVXXFLAGS) $(WARN_FLAGS) 

$(OBJ)/%.cc.o: $(SRC)/%.cc $(INC)/%.h
	$(CXX) -c $< -o $@ $(WARN_FLAGS) $(CXXFLAGS) $(CXX_LINK_FLAGS) $(INC_FLAGS) $(LIB_FLAGS) $(CUDA_INC_DIR) $(CUDA_LIB_DIR)

$(OBJ)/%.cu.o: $(SRC)/%.cu $(INC)/%.cuh
	$(NVXX) -c $< -o $@ $(NVXXFLAGS) $(NVXX_LINK_FLAGS) $(INC_FLAGS) $(LIB_FLAGS) $(CXX_LINK_FLAGS) $(CUDA_LIB_DIR) $(CUDA_INC_DIR)


.PHONY: clean

clean:
	find ${OBJ} -name *.o -exec rm -r {} \;
	rm -f exe
